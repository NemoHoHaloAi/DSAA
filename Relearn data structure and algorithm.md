# [Relearn data structure and algorithm](https://kaiwu.lagou.com/course/courseInfo.htm?courseId=185&utm_source=%E5%85%AC%E4%BC%97%E5%8F%B7%E8%8F%9C%E5%8D%95&utm_medium=%E9%87%8D%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%8F%9C%E5%8D%95&utm_campaign=%E8%AF%BE%E7%A8%8B%E6%B8%A0%E9%81%93%E6%8E%A8%E5%B9%BF#/detail/pc?id=3339)

一个小目标：利用数据结构的**知识**，建立算法**思维**，完成代码**效率**的优化；

目录结构：

1. 方法论；
2. 方法论指引下，补充数据结构基础知识；
3. 方法论指引下，补充必备的算法思维；
4. 真题详解，用之前的方法论、体系、知识解题；
5. 切实建议；

## 代码效率优化与方法论

### 复杂度：如何衡量程序运行效率

#### 复杂度定义及计算

1. 消耗的资源是什么：代码运行过程中消耗时间和空间，因此复杂度分为时间复杂度和空间复杂度；
2. 消耗了多少资源：一般不关心资源消耗的绝对量，因为不同输入对应这个量差异很大，没有参考性，而是关注资源消耗与输入之间的相对关系；
3. 如何计算：
    1. 复杂度与常数无关，即O(2n)与O(n)在复杂度上是一致的，O(2n)=O(n)+O(n)，也就是O(n)执行两次，属于常数范围；
    2. 多项式级复杂度相加时选择最高的作为结果，O(n^2)+O(n)，那么结果就是O(n^2)，因为我们知道随做n越来越大，整个结果中二次方的占比要远远高于一次方；
    3. O(1)是一个特殊的复杂度，表示与输入数量n无关；
4. 一个例子，对输入数组逆序输出：
    1. 方法1：建立初始化数组b，与输入等长全为0，通过for循环遍历输入数组并从右到左赋值到数组b，输出b数组；
        1. 有单层循环，但是没有嵌套，且循环次数为输入数组长度，因此时间复杂度为O(n)；
        2. 初始化了数组b，长度与输入数组一致，因此空间复杂度为O(n)；
    2. 方法2：定义中间变量tmp，遍历输入数组长度的一半，每次循环交换当前位置与其对应的倒数位置的元素，输出输入数组；
        1. 单层循环，次数为n/2，与常数无关，所以时间复杂度为O(n)；
        2. 没有定义其他数组，只有一个变量tmp，与输入数组长度无关，复杂度为O(1)；

#### 时间复杂度与代码结构的关系

- 顺序结构的代码（没有循环），复杂度为O(1)；
- 二分查找、分而治之等，复杂度为O(logn)；
- 一个循环，复杂度为O(n)；
- 两个循环，但是不嵌套（不管几个，只要不嵌套，复杂度就是O(n)），复杂度依然为O(n)；
- 两个循环嵌套，复杂度为O(n*n)；

#### 降低时间复杂度的必要性

大规模请求下，复杂度的差异带来的绝对处理时间空间差异就非常明显，因此切实的存在优化的必要；

### 数据结构：空间换时间

代码优化，就是将可行解优化到最优或者近最优解；

#### 时间昂贵、空间廉价

一般来说，空间复杂度问题可以通过提升硬件性能等方式变相解决，而时间复杂度往往更加棘手，因此产生了一种时间昂贵，空间廉价的感觉；

#### 数据结构链接时空

立交桥的使用是典型的用立体空间来置换时间，立交桥就可以看作是这种场景下使用的一种比普通十字路口更复杂（空间复杂度更高）的数据结构；

一般的优化核心思路：

1. 暴力解法，没有任何时间空间约束下完成开发任务；
2. Review代码，去除多余的变量、计算、存储等；
3. 时空转换，设计更加合理的数据结构，实现时间复杂度的降低；

#### 降低复杂度例子

- 例子1：面值为2，3，7的纸币，凑出100块，总共有多少种可能？

    1. 暴力法：三层循环嵌套，每层遍历从0到100/该层面值，最内层判断相加和是否为100，完成统计，时间复杂度为O(n^3)，空间复杂度为O(1)；

        ```java
        public void s2_1() {
        	int count = 0;
        	for (int i = 0; i < (100 / 7); i++) {
        		for (int j = 0; j < (100 / 3); j++) {
        			for (int k = 0; k < (100 / 2); k++) {
        				if (i * 7 + j * 3 + k * 2 == 100) {
        					count += 1;
        				}
        			}
        		}
        	}
        	System.out.println(count);
        }
        ```

        

    2. Review发现，最内层循环是多余的，因为当前两层的纸币数量确认后，第三层就也确定了，因此可以去除，时间复杂度降为O(n^2)；

        ```java
        public void s2_2() {
        	int count = 0;
        	for (int i = 0; i < (100 / 7); i++) {
        		for (int j = 0; j < (100 / 3); j++) {
        			if ((100 - i * 7 - j * 3) % 2 == 0) {
        				count += 1;
        			}
        		}
        	}
        	System.out.println(count);
        }
        ```

- 例子2：查找数组中出现次数最多的数字并输出；

    1. 暴力法：两层循环嵌套，依次判断每个数与其他数是否一致并统计个数，最后输出此处最多的数字，时间复杂度为O(n^2)，空间复杂度为O(1)；

        ```java
        public void s2_3() {
        	int a[] = { 1, 2, 3, 4, 5, 5, 6 };
        	int val_max = -1;
        	int time_max = 0;
        	int time_tmp = 0;
        	for (int i = 0; i < a.length; i++) {
        		time_tmp = 0;
        		for (int j = 0; j < a.length; j++) {
        			if (a[i] == a[j]) {
        				time_tmp += 1;
        			}
        			if (time_tmp > time_max) {
        				time_max = time_tmp;
        				val_max = a[i];
        			}
        		}
        	}
        	System.out.println(val_max);
        }
        ```

    2. 时空转换：定义字典用于统计每个数字出现的次数，最后遍历字段即可得到最大值，虽然看似还是有两个循环，但是不嵌套，所以时间复杂度降低为O(n)，同时空间复杂度上升为O(n)；

        ```java
        public void s2_4() {
        	int a[] = { 1, 2, 3, 4, 5, 5, 6 };
        	Map<Integer, Integer> d = new HashMap<>();
        	for (int i = 0; i < a.length; i++) {
        		if (d.containsKey(a[i])) {
        			d.put(a[i], d.get(a[i]) + 1);
        		} else {
        			d.put(a[i], 1);
        		}
        	}
        	int val_max = -1;
        	int time_max = 0;
        	int count = 0;
        	for (Integer key : d.keySet()) {
        		if (d.get(key) > time_max) {
        			time_max = d.get(key);
        			val_max = count;
        		}
        		count++;
        	}
        	System.out.println(d);
        }
        ```

        

## 数据结构基础

### 增删查：基础数据处理操作

#### 代码对数据的处理

依然是从数组中找出现次数最多的例子，优化后使用字典存储每个数字以及其出现的次数，为什么选择用字典呢？

流程分析：

1. 第一层循环中对存储结果主要需要进行查找、新增、修改操作；
2. 第二层循环中对存储结果主要使用查找；

注意，此处这些操作都是在循环内部的，如果某个操作依然具备大于等于O(n)的复杂度，那么整体的复杂度就依然是O(n^2)，因此选择字典而不是两个数组分别存储k和v的原因在于字典的key查找复杂度为O(1)（比如通过hash计算等直接拿到key对应的位置，当前这里的例子比较简单，key为数字，本质上可以通过数组下标来表示，复杂度也是O(1)，但是在更复杂的场景下，比如key为字符串，那么就依然是O(n)）；

#### 数据处理基本操作

不同的数据结构在消耗同样的空间资源时，不见得都能对时间复杂度起到一样的作用，这就是为什么不仅仅要使用数据结构，而且要设计**合理**的数据结构；

设计数据结构的思考顺序：

1. 分析代码到底对数据先后进行了哪些操作；
2. 根据分析出的这些操作，找到合理的数据结构（常说的查找多还是增删多）；

基本操作：

1. 查找，使用率最多的操作，将内存中某个区间内容读出来；
2. 新增，向一个新的内存空间中写入数据；
3. 修改，向一个旧的内存空间中覆盖写入数据；

分析步骤：

1. 这段代码对数据做了什么操作；
2. 这些操作中哪个最影响效率，对时间复杂度的损耗最大；
3. 哪种数据结构能够有效提高数据操作效率；

#### 数据操作与数据结构的例子

- 例子1：根据位置查找元素：
    - 数组：复杂度为O(1)，因为数组本身有index索引；
    - 链表：复杂度为O(n)，空间复杂度与数组一样都是O(n)，但它各个元素通过指针连接，因此只能从头向后遍历找某个位置；
- 例子2：根据数值查找元素：
    - 数组、链表：复杂度都是O(n)，说白了就是这两种数据结构中都没有存储与元素数值之间关系的信息，因此只能一个一个遍历；
    - 字典：将数值作为key存储后查找的复杂度为O(1)；
- 例子3：在数据结构中新增元素：
    - 这里分两种情况：
        - 在最后新增，也就是对原始结构没有影响；
        - 在中间新增，那么对原始结构是有影响的；
    - 删除元素情况类似；
    - 这种情况下数组的复杂度为O(n)，因为涉及到元素移位（读写内存），而链表虽然也是O(n)，但它主要在于查找，相对来说还是链表效率更高；
- 例子4：在某个数据结构中，在第二个元素后新增一个数据，然后删除第一个满足数值大于6的元素：
    - 第一步：涉及查找和新增两个操作，查找到第二个元素，并插入新元素；
    - 第二步：涉及查找和删除两个操作，首先通过查找定位到满足条件的元素，然后删除；

### 如何完成线性表结果下的增删查

### 栈：先进后出的线性表，如何实现增删查

### 队列：先进先出的线性表，如何实现的增删查

### 数组：如何实现基于索引的查找

## 算法思维基础

## 真题详解

## 最后