# [Relearn data structure and algorithm](https://kaiwu.lagou.com/course/courseInfo.htm?courseId=185&utm_source=%E5%85%AC%E4%BC%97%E5%8F%B7%E8%8F%9C%E5%8D%95&utm_medium=%E9%87%8D%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%8F%9C%E5%8D%95&utm_campaign=%E8%AF%BE%E7%A8%8B%E6%B8%A0%E9%81%93%E6%8E%A8%E5%B9%BF#/detail/pc?id=3339)

一个小目标：利用数据结构的**知识**，建立算法**思维**，完成代码**效率**的优化；

目录结构：

1. 方法论；
2. 方法论指引下，补充数据结构基础知识；
3. 方法论指引下，补充必备的算法思维；
4. 真题详解，用之前的方法论、体系、知识解题；
5. 切实建议；

## 代码效率优化与方法论

### 复杂度：如何衡量程序运行效率

#### 复杂度定义及计算

1. 消耗的资源是什么：代码运行过程中消耗时间和空间，因此复杂度分为时间复杂度和空间复杂度；
2. 消耗了多少资源：一般不关心资源消耗的绝对量，因为不同输入对应这个量差异很大，没有参考性，而是关注资源消耗与输入之间的相对关系；
3. 如何计算：
    1. 复杂度与常数无关，即O(2n)与O(n)在复杂度上是一致的，O(2n)=O(n)+O(n)，也就是O(n)执行两次，属于常数范围；
    2. 多项式级复杂度相加时选择最高的作为结果，O(n^2)+O(n)，那么结果就是O(n^2)，因为我们知道随做n越来越大，整个结果中二次方的占比要远远高于一次方；
    3. O(1)是一个特殊的复杂度，表示与输入数量n无关；
4. 一个例子，对输入数组逆序输出：
    1. 方法1：建立初始化数组b，与输入等长全为0，通过for循环遍历输入数组并从右到左赋值到数组b，输出b数组；
        1. 有单层循环，但是没有嵌套，且循环次数为输入数组长度，因此时间复杂度为O(n)；
        2. 初始化了数组b，长度与输入数组一致，因此空间复杂度为O(n)；
    2. 方法2：定义中间变量tmp，遍历输入数组长度的一半，每次循环交换当前位置与其对应的倒数位置的元素，输出输入数组；
        1. 单层循环，次数为n/2，与常数无关，所以时间复杂度为O(n)；
        2. 没有定义其他数组，只有一个变量tmp，与输入数组长度无关，复杂度为O(1)；

#### 时间复杂度与代码结构的关系

- 顺序结构的代码（没有循环），复杂度为O(1)；
- 二分查找、分而治之等，复杂度为O(logn)；
- 一个循环，复杂度为O(n)；
- 两个循环，但是不嵌套（不管几个，只要不嵌套，复杂度就是O(n)），复杂度依然为O(n)；
- 两个循环嵌套，复杂度为O(n*n)；

#### 降低时间复杂度的必要性

大规模请求下，复杂度的差异带来的绝对处理时间空间差异就非常明显，因此切实的存在优化的必要；

### 数据结构：空间换时间

代码优化，就是将可行解优化到最优或者近最优解；

#### 时间昂贵、空间廉价

一般来说，空间复杂度问题可以通过提升硬件性能等方式变相解决，而时间复杂度往往更加棘手，因此产生了一种时间昂贵，空间廉价的感觉；

#### 数据结构链接时空

立交桥的使用是典型的用立体空间来置换时间，立交桥就可以看作是这种场景下使用的一种比普通十字路口更复杂（空间复杂度更高）的数据结构；

一般的优化核心思路：

1. 暴力解法，没有任何时间空间约束下完成开发任务；
2. Review代码，去除多余的变量、计算、存储等；
3. 时空转换，设计更加合理的数据结构，实现时间复杂度的降低；

#### 降低复杂度例子

- 例子1：面值为2，3，7的纸币，凑出100块，总共有多少种可能？

    1. 暴力法：三层循环嵌套，每层遍历从0到100/该层面值，最内层判断相加和是否为100，完成统计，时间复杂度为O(n^3)，空间复杂度为O(1)；

        ```java
        public void s2_1() {
        	int count = 0;
        	for (int i = 0; i < (100 / 7); i++) {
        		for (int j = 0; j < (100 / 3); j++) {
        			for (int k = 0; k < (100 / 2); k++) {
        				if (i * 7 + j * 3 + k * 2 == 100) {
        					count += 1;
        				}
        			}
        		}
        	}
        	System.out.println(count);
        }
        ```

        

    2. Review发现，最内层循环是多余的，因为当前两层的纸币数量确认后，第三层就也确定了，因此可以去除，时间复杂度降为O(n^2)；

        ```java
        public void s2_2() {
        	int count = 0;
        	for (int i = 0; i < (100 / 7); i++) {
        		for (int j = 0; j < (100 / 3); j++) {
        			if ((100 - i * 7 - j * 3) % 2 == 0) {
        				count += 1;
        			}
        		}
        	}
        	System.out.println(count);
        }
        ```

- 例子2：查找数组中出现次数最多的数字并输出；

    1. 暴力法：两层循环嵌套，依次判断每个数与其他数是否一致并统计个数，最后输出此处最多的数字，时间复杂度为O(n^2)，空间复杂度为O(1)；

        ```java
        public void s2_3() {
        	int a[] = { 1, 2, 3, 4, 5, 5, 6 };
        	int val_max = -1;
        	int time_max = 0;
        	int time_tmp = 0;
        	for (int i = 0; i < a.length; i++) {
        		time_tmp = 0;
        		for (int j = 0; j < a.length; j++) {
        			if (a[i] == a[j]) {
        				time_tmp += 1;
        			}
        			if (time_tmp > time_max) {
        				time_max = time_tmp;
        				val_max = a[i];
        			}
        		}
        	}
        	System.out.println(val_max);
        }
        ```

    2. 时空转换：定义字典用于统计每个数字出现的次数，最后遍历字段即可得到最大值，虽然看似还是有两个循环，但是不嵌套，所以时间复杂度降低为O(n)，同时空间复杂度上升为O(n)；

        ```java
        public void s2_4() {
        	int a[] = { 1, 2, 3, 4, 5, 5, 6 };
        	Map<Integer, Integer> d = new HashMap<>();
        	for (int i = 0; i < a.length; i++) {
        		if (d.containsKey(a[i])) {
        			d.put(a[i], d.get(a[i]) + 1);
        		} else {
        			d.put(a[i], 1);
        		}
        	}
        	int val_max = -1;
        	int time_max = 0;
        	int count = 0;
        	for (Integer key : d.keySet()) {
        		if (d.get(key) > time_max) {
        			time_max = d.get(key);
        			val_max = count;
        		}
        		count++;
        	}
        	System.out.println(d);
        }
        ```

        

## 数据结构基础

### 增删查：基础数据处理操作

#### 代码对数据的处理

依然是从数组中找出现次数最多的例子，优化后使用字典存储每个数字以及其出现的次数，为什么选择用字典呢？

流程分析：

1. 第一层循环中对存储结果主要需要进行查找、新增、修改操作；
2. 第二层循环中对存储结果主要使用查找；

注意，此处这些操作都是在循环内部的，如果某个操作依然具备大于等于O(n)的复杂度，那么整体的复杂度就依然是O(n^2)，因此选择字典而不是两个数组分别存储k和v的原因在于字典的key查找复杂度为O(1)（比如通过hash计算等直接拿到key对应的位置，当前这里的例子比较简单，key为数字，本质上可以通过数组下标来表示，复杂度也是O(1)，但是在更复杂的场景下，比如key为字符串，那么就依然是O(n)）；

#### 数据处理基本操作

不同的数据结构在消耗同样的空间资源时，不见得都能对时间复杂度起到一样的作用，这就是为什么不仅仅要使用数据结构，而且要设计**合理**的数据结构；

设计数据结构的思考顺序：

1. 分析代码到底对数据先后进行了哪些操作；
2. 根据分析出的这些操作，找到合理的数据结构（常说的查找多还是增删多）；

基本操作：

1. 查找，使用率最多的操作，将内存中某个区间内容读出来；
2. 新增，向一个新的内存空间中写入数据；
3. 修改，向一个旧的内存空间中覆盖写入数据；

分析步骤：

1. 这段代码对数据做了什么操作；
2. 这些操作中哪个最影响效率，对时间复杂度的损耗最大；
3. 哪种数据结构能够有效提高数据操作效率；

#### 数据操作与数据结构的例子

- 例子1：根据位置查找元素：
    - 数组：复杂度为O(1)，因为数组本身有index索引；
    - 链表：复杂度为O(n)，空间复杂度与数组一样都是O(n)，但它各个元素通过指针连接，因此只能从头向后遍历找某个位置；
- 例子2：根据数值查找元素：
    - 数组、链表：复杂度都是O(n)，说白了就是这两种数据结构中都没有存储与元素数值之间关系的信息，因此只能一个一个遍历；
    - 字典：将数值作为key存储后查找的复杂度为O(1)；
- 例子3：在数据结构中新增元素：
    - 这里分两种情况：
        - 在最后新增，也就是对原始结构没有影响；
        - 在中间新增，那么对原始结构是有影响的；
    - 删除元素情况类似；
    - 这种情况下数组的复杂度为O(n)，因为涉及到元素移位（读写内存），而链表虽然也是O(n)，但它主要在于查找，相对来说还是链表效率更高；
- 例子4：在某个数据结构中，在第二个元素后新增一个数据，然后删除第一个满足数值大于6的元素：
    - 第一步：涉及查找和新增两个操作，查找到第二个元素，并插入新元素；
    - 第二步：涉及查找和删除两个操作，首先通过查找定位到满足条件的元素，然后删除；

### 线性表：如何实现增删查

最常见的是链表形式，也叫做线性链表；

单向链表：最简单的链表由一个个节点组成，每个节点包含当前节点值以及指向下一个节点的指针，最后一个节点的指针为空；

循环链表：最后一个节点的指针指向第一个节点，循环一个环状的结构；

双向链表：为了解决链表中的节点无法索引到自己的上一个节点的问题，引入双向链表结构，每个节点中分别存储指向前后两个节点的指针；

双向循环链表：循环+双向；

增删：只需要找到对应位置，修改前后元素指针即可，复杂度O(1)；

查找：需要从头遍历，复杂度为O(n)；

注意：虽然链表增删复杂度只有O(1)，但是增删一般都伴随这查找，比如在第5个位置加入一个元素，那么需要现查找再增加，复杂度为O(n)+O(1)，因此依然为O(n)；

#### 链表的例子

链表的例子普遍集中于在链表的弱势方面做文章，比如无法直接获取长度，比如单向链表无法向后，比如查找慢等；

- 例子1：翻转链表；
    - 难点在于节点之间连接一旦打破就失去了对后续数据的索引；
    - 创建多个指针，至少有一个多余指针用于存储当前节点的下一个节点，避免当前节点指针改为上一个后失去对下一个的索引；
- 例子2：找到奇数长度链表的中间节点；
    - 针对链表无法直接获取长度的问题；
    - 暴力法是一轮循环计算长度，再来一轮找到中间位置；
    - 巧妙法：**快慢指针**，快指针一次走两步，满指针一次走一步，当快指针到达最后一个节点时，满指针刚好处于中间位置，这里利用了总长度与中间位置的2倍关系；
- 例子3：链表内是否有环，即尾节点指向前方的另一个节点形成局部环状；
    - 快慢指针，如果有环，那么两个指针总会在环内相遇，即fast==slow；
    - 总会相遇：因为快指针是慢指针的两倍，而一旦二者相等，那么很显然是快指针绕回来了，也就是有环状结构；

### 栈：先进后出的线性表，如何实现增删查

可以看作是对线性表做了后进先出的限制；

实际应用：

- android界面；
- 浏览器前进后退；
- 程序堆栈结构；

#### 栈的存储形式

顺序栈：使用数组实现的栈结构；

链栈：使用链表实现的栈结构；

#### 栈的例子

- 例子1：括号匹配合法性检查；
    - 左括号压栈，后括号出栈，看是否能正确匹配，这种嵌套关系用后进先出描述了出来；
- 例子2：浏览器的前进后退管理；
    - 维护两个栈，分别表示用于前进和后退的，初始都是空，用户打开一个链接，压入前进栈，再打开一个再压入，用户点击后退，此时前进展出栈，并压入后退栈；

### 队列：先进先出的线性表，如何实现的增删查



### 数组：如何实现基于索引的查找

## 算法思维基础

## 真题详解

## 最后