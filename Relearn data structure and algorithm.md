# [Relearn data structure and algorithm](https://kaiwu.lagou.com/course/courseInfo.htm?courseId=185&utm_source=%E5%85%AC%E4%BC%97%E5%8F%B7%E8%8F%9C%E5%8D%95&utm_medium=%E9%87%8D%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%8F%9C%E5%8D%95&utm_campaign=%E8%AF%BE%E7%A8%8B%E6%B8%A0%E9%81%93%E6%8E%A8%E5%B9%BF#/detail/pc?id=3339)

一个小目标：利用数据结构的**知识**，建立算法**思维**，完成代码**效率**的优化；

目录结构：

1. 方法论；
2. 方法论指引下，补充数据结构基础知识；
3. 方法论指引下，补充必备的算法思维；
4. 真题详解，用之前的方法论、体系、知识解题；
5. 切实建议；

## 代码效率优化与方法论

### 复杂度：如何衡量程序运行效率

#### 复杂度定义及计算

1. 消耗的资源是什么：代码运行过程中消耗时间和空间，因此复杂度分为时间复杂度和空间复杂度；
2. 消耗了多少资源：一般不关心资源消耗的绝对量，因为不同输入对应这个量差异很大，没有参考性，而是关注资源消耗与输入之间的相对关系；
3. 如何计算：
    1. 复杂度与常数无关，即O(2n)与O(n)在复杂度上是一致的，O(2n)=O(n)+O(n)，也就是O(n)执行两次，属于常数范围；
    2. 多项式级复杂度相加时选择最高的作为结果，O(n^2)+O(n)，那么结果就是O(n^2)，因为我们知道随做n越来越大，整个结果中二次方的占比要远远高于一次方；
    3. O(1)是一个特殊的复杂度，表示与输入数量n无关；
4. 一个例子，对输入数组逆序输出：
    1. 方法1：建立初始化数组b，与输入等长全为0，通过for循环遍历输入数组并从右到左赋值到数组b，输出b数组；
        1. 有单层循环，但是没有嵌套，且循环次数为输入数组长度，因此时间复杂度为O(n)；
        2. 初始化了数组b，长度与输入数组一致，因此空间复杂度为O(n)；
    2. 方法2：定义中间变量tmp，遍历输入数组长度的一半，每次循环交换当前位置与其对应的倒数位置的元素，输出输入数组；
        1. 单层循环，次数为n/2，与常数无关，所以时间复杂度为O(n)；
        2. 没有定义其他数组，只有一个变量tmp，与输入数组长度无关，复杂度为O(1)；

#### 时间复杂度与代码结构的关系

- 顺序结构的代码（没有循环），复杂度为O(1)；
- 二分查找、分而治之等，复杂度为O(logn)；
- 一个循环，复杂度为O(n)；
- 两个循环，但是不嵌套（不管几个，只要不嵌套，复杂度就是O(n)），复杂度依然为O(n)；
- 两个循环嵌套，复杂度为O(n*n)；

#### 降低时间复杂度的必要性

大规模请求下，复杂度的差异带来的绝对处理时间空间差异就非常明显，因此切实的存在优化的必要；

### 数据结构：空间换时间

代码优化，就是将可行解优化到最优或者近最优解；

#### 时间昂贵、空间廉价

一般来说，空间复杂度问题可以通过提升硬件性能等方式变相解决，而时间复杂度往往更加棘手，因此产生了一种时间昂贵，空间廉价的感觉；

#### 数据结构链接时空

立交桥的使用是典型的用立体空间来置换时间，立交桥就可以看作是这种场景下使用的一种比普通十字路口更复杂（空间复杂度更高）的数据结构；

一般的优化核心思路：

1. 暴力解法，没有任何时间空间约束下完成开发任务；
2. Review代码，去除多余的变量、计算、存储等；
3. 时空转换，设计更加合理的数据结构，实现时间复杂度的降低；

#### 降低复杂度例子

- 例子1：面值为2，3，7的纸币，凑出100块，总共有多少种可能？

    1. 暴力法：三层循环嵌套，每层遍历从0到100/该层面值，最内层判断相加和是否为100，完成统计，时间复杂度为O(n^3)，空间复杂度为O(1)；

        ```java
        public void s2_1() {
        	int count = 0;
        	for (int i = 0; i < (100 / 7); i++) {
        		for (int j = 0; j < (100 / 3); j++) {
        			for (int k = 0; k < (100 / 2); k++) {
        				if (i * 7 + j * 3 + k * 2 == 100) {
        					count += 1;
        				}
        			}
        		}
        	}
        	System.out.println(count);
        }
        ```

        

    2. Review发现，最内层循环是多余的，因为当前两层的纸币数量确认后，第三层就也确定了，因此可以去除，时间复杂度降为O(n^2)；

        ```java
        public void s2_2() {
        	int count = 0;
        	for (int i = 0; i < (100 / 7); i++) {
        		for (int j = 0; j < (100 / 3); j++) {
        			if ((100 - i * 7 - j * 3) % 2 == 0) {
        				count += 1;
        			}
        		}
        	}
        	System.out.println(count);
        }
        ```

- 例子2：查找数组中出现次数最多的数字并输出；

    1. 暴力法：两层循环嵌套，依次判断每个数与其他数是否一致并统计个数，最后输出此处最多的数字，时间复杂度为O(n^2)，空间复杂度为O(1)；

        ```java
        public void s2_3() {
        	int a[] = { 1, 2, 3, 4, 5, 5, 6 };
        	int val_max = -1;
        	int time_max = 0;
        	int time_tmp = 0;
        	for (int i = 0; i < a.length; i++) {
        		time_tmp = 0;
        		for (int j = 0; j < a.length; j++) {
        			if (a[i] == a[j]) {
        				time_tmp += 1;
        			}
        			if (time_tmp > time_max) {
        				time_max = time_tmp;
        				val_max = a[i];
        			}
        		}
        	}
        	System.out.println(val_max);
        }
        ```

    2. 时空转换：定义字典用于统计每个数字出现的次数，最后遍历字段即可得到最大值，虽然看似还是有两个循环，但是不嵌套，所以时间复杂度降低为O(n)，同时空间复杂度上升为O(n)；

        ```java
        public void s2_4() {
        	int a[] = { 1, 2, 3, 4, 5, 5, 6 };
        	Map<Integer, Integer> d = new HashMap<>();
        	for (int i = 0; i < a.length; i++) {
        		if (d.containsKey(a[i])) {
        			d.put(a[i], d.get(a[i]) + 1);
        		} else {
        			d.put(a[i], 1);
        		}
        	}
        	int val_max = -1;
        	int time_max = 0;
        	int count = 0;
        	for (Integer key : d.keySet()) {
        		if (d.get(key) > time_max) {
        			time_max = d.get(key);
        			val_max = count;
        		}
        		count++;
        	}
        	System.out.println(d);
        }
        ```

        

## 数据结构基础

### 增删查：基础数据处理操作

#### 代码对数据的处理

依然是从数组中找出现次数最多的例子，优化后使用字典存储每个数字以及其出现的次数，为什么选择用字典呢？

流程分析：

1. 第一层循环中对存储结果主要需要进行查找、新增、修改操作；
2. 第二层循环中对存储结果主要使用查找；

注意，此处这些操作都是在循环内部的，如果某个操作依然具备大于等于O(n)的复杂度，那么整体的复杂度就依然是O(n^2)，因此选择字典而不是两个数组分别存储k和v的原因在于字典的key查找复杂度为O(1)（比如通过hash计算等直接拿到key对应的位置，当前这里的例子比较简单，key为数字，本质上可以通过数组下标来表示，复杂度也是O(1)，但是在更复杂的场景下，比如key为字符串，那么就依然是O(n)）；

#### 数据处理基本操作

不同的数据结构在消耗同样的空间资源时，不见得都能对时间复杂度起到一样的作用，这就是为什么不仅仅要使用数据结构，而且要设计**合理**的数据结构；

设计数据结构的思考顺序：

1. 分析代码到底对数据先后进行了哪些操作；
2. 根据分析出的这些操作，找到合理的数据结构（常说的查找多还是增删多）；

基本操作：

1. 查找，使用率最多的操作，将内存中某个区间内容读出来；
2. 新增，向一个新的内存空间中写入数据；
3. 修改，向一个旧的内存空间中覆盖写入数据；

分析步骤：

1. 这段代码对数据做了什么操作；
2. 这些操作中哪个最影响效率，对时间复杂度的损耗最大；
3. 哪种数据结构能够有效提高数据操作效率；

#### 数据操作与数据结构的例子

- 例子1：根据位置查找元素：
    - 数组：复杂度为O(1)，因为数组本身有index索引；
    - 链表：复杂度为O(n)，空间复杂度与数组一样都是O(n)，但它各个元素通过指针连接，因此只能从头向后遍历找某个位置；
- 例子2：根据数值查找元素：
    - 数组、链表：复杂度都是O(n)，说白了就是这两种数据结构中都没有存储与元素数值之间关系的信息，因此只能一个一个遍历；
    - 字典：将数值作为key存储后查找的复杂度为O(1)；
- 例子3：在数据结构中新增元素：
    - 这里分两种情况：
        - 在最后新增，也就是对原始结构没有影响；
        - 在中间新增，那么对原始结构是有影响的；
    - 删除元素情况类似；
    - 这种情况下数组的复杂度为O(n)，因为涉及到元素移位（读写内存），而链表虽然也是O(n)，但它主要在于查找，相对来说还是链表效率更高；
- 例子4：在某个数据结构中，在第二个元素后新增一个数据，然后删除第一个满足数值大于6的元素：
    - 第一步：涉及查找和新增两个操作，查找到第二个元素，并插入新元素；
    - 第二步：涉及查找和删除两个操作，首先通过查找定位到满足条件的元素，然后删除；

### 线性表：如何实现增删查

最常见的是链表形式，也叫做线性链表；

单向链表：最简单的链表由一个个节点组成，每个节点包含当前节点值以及指向下一个节点的指针，最后一个节点的指针为空；

循环链表：最后一个节点的指针指向第一个节点，循环一个环状的结构；

双向链表：为了解决链表中的节点无法索引到自己的上一个节点的问题，引入双向链表结构，每个节点中分别存储指向前后两个节点的指针；

双向循环链表：循环+双向；

增删：只需要找到对应位置，修改前后元素指针即可，复杂度O(1)；

查找：需要从头遍历，复杂度为O(n)；

注意：虽然链表增删复杂度只有O(1)，但是增删一般都伴随这查找，比如在第5个位置加入一个元素，那么需要现查找再增加，复杂度为O(n)+O(1)，因此依然为O(n)；

#### 链表的例子

链表的例子普遍集中于在链表的弱势方面做文章，比如无法直接获取长度，比如单向链表无法向后，比如查找慢等；

- 例子1：翻转链表；
    - 难点在于节点之间连接一旦打破就失去了对后续数据的索引；
    - 创建多个指针，至少有一个多余指针用于存储当前节点的下一个节点，避免当前节点指针改为上一个后失去对下一个的索引；
- 例子2：找到奇数长度链表的中间节点；
    - 针对链表无法直接获取长度的问题；
    - 暴力法是一轮循环计算长度，再来一轮找到中间位置；
    - 巧妙法：**快慢指针**，快指针一次走两步，满指针一次走一步，当快指针到达最后一个节点时，满指针刚好处于中间位置，这里利用了总长度与中间位置的2倍关系；
- 例子3：链表内是否有环，即尾节点指向前方的另一个节点形成局部环状；
    - 快慢指针，如果有环，那么两个指针总会在环内相遇，即fast==slow；
    - 总会相遇：因为快指针是慢指针的两倍，而一旦二者相等，那么很显然是快指针绕回来了，也就是有环状结构；

### 栈：先进后出的线性表，如何实现增删查

可以看作是对线性表做了后进先出的限制；

实际应用：

- android界面；
- 浏览器前进后退；
- 程序堆栈结构；

#### 栈的存储形式

顺序栈：使用数组实现的栈结构；

链栈：使用链表实现的栈结构；

#### 栈的例子

- 例子1：括号匹配合法性检查；
    - 左括号压栈，后括号出栈，看是否能正确匹配，这种嵌套关系用后进先出描述了出来；
- 例子2：浏览器的前进后退管理；
    - 维护两个栈，分别表示用于前进和后退的，初始都是空，用户打开一个链接，压入前进栈，再打开一个再压入，用户点击后退，此时前进展出栈，并压入后退栈；

### 队列：先进先出的线性表，如何实现的增删查

先进先出的线性表，存在顺序队列（数组+头尾指针）和链式队列（链表+头尾指针）两种形式；

#### 两种形式

顺序队列的增删：

- 增加元素：可以通过移动尾指针，复杂度为O(1)；

- 删除元素：如果通过移动元素，那么复杂度为O(n)，如果通过移动头指针，复杂度为O(1)，但是可能由指针越界问题，也就是“假溢出”问题，解决方法如下：

    - 删除元素使用移动的方法；

    - 开辟足够大的内存空间保证数组不会越界；

    - **循环队列**：

        - 其实此时队列的头部是有空闲空间的，只是没有利用；
        - 问题：头尾指针指向同一个位置时即可能表示空，也可能表示满，需要单独的flag标记；
        - 代码实现上更复杂，但是可以在不占用额外的内存空间情况下保证O(1)的复杂度；

        ![image-20200616140815989](C:\Users\pc001\AppData\Roaming\Typora\typora-user-images\image-20200616140815989.png)

链式队列（空的头节点）的增删：

- 增加元素：新节点赋值给尾指针的next，尾指针指向新节点，复杂度为O(1)；
- 删除元素：头节点指向自身下一个节点的next，注意如果此时只有要给节点了，那么需要把为节点指向空的头节点，避免为节点指向一个被删除的节点，成为野指针，复杂度为O(1)；

对于按值查找，顺序队列和链式队列都需要O(n)，如果时按索引，那么基于数组的永远都是O(1)，而基于链表的则是O(n)；

#### 例子

- 例子1：约瑟夫环；

    - 约瑟夫环是一个数学的应用问题，具体为，已知 n 个人（以编号 1，2，3...n 分别表示）围坐在一张圆桌周围。从编号为 k 的人开始报数，数到 m 的那个人出列；他的下一个人又从 1 开始报数，数到 m 的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。这个问题的输入变量就是 n 和 m，即 n 个人和数到 m 的出列的人。输出的结果，就是 n 个人出列的顺序。

    - 循环队列的方式解决：

        - 因为是循环，满足重复着数的条件；
        - 因为是队列，先进先出，满足转着数；

        ![circle_queue](E:\gifs\circle_queue.gif)

### 数组：如何实现基于索引的查找

存放某种相同类型数据的连续的内存空间；

#### 数组的操作

- 增加元素：需要将对应位置及之后所有元素后移，然后再插入，其中找到对应位置为O(1)，但是移动插入等为O(n)，因此复杂度为O(n)；
- 删除元素：如果删除的是最后一个元素，那么直接删除，复杂度为O(1)，比如顺序栈或者顺序列表的头尾操作，如果删除的是其他位置元素，那么同样为O(n)；
- 查找：由于数组的元素类型是确定的，在内存的起始地址是固定的，因此可以直接推导出某个位置的元素，因此按位置索引的复杂度为O(1)，注意如果是按值查找，那么依然是O(n)；

#### 对比链表

1. 数组按位置索引元素更快；
2. 增删元素基本一致，差异在于数组的O(n)是移动元素的O(n)，而链表的O(n)是遍历节点的O(n)；
3. 数组是连续内存空间，因此对于碎片化的内存空间的利用不是很充分，链表是分散存储，由指针链接起来；

#### 例子

- 针对长度为5的数组，去除最大最小值后求均值：
    - 遍历数组找最大最小值，复杂度为O(n)；
    - 根据上述得到的两个索引分别进行两次数组元素的删除，复杂度为O(n)+O(n)；
    - 遍历删除后数组求和，复杂度为O(n)；
    - 求均值；
    - 最终复杂度为O(n)+O(n)+O(n)+O(n)+O(1)，依然为O(n)；

### 字符串：如何正确回答面试中高频考察的字符串匹配算法

字符串就是一连串的字符组成的序列，在C中，字符串可以由字符数组表示，因此可以看出，它的存储结构与数组是非常类似甚至可以说就是一种特殊的数组；

#### 存储结构

- 顺序存储：使用类似数组的形式存储，通常使用\0表示字符串的结束符；
- 链式存储：每个节点可以存储1个或者多个字符，具体存储几个取决于实际业务需求；

#### 字符串基本操作

原子操作上与线性表是非常类似的，但是由于字符串的特殊应用场景，因此会具有很多高频的操作，比如多字符操作、子串查找，旋转，切割字符串等等；

下面以**顺序存储**的字符串为例：

- 增加单个或多个字符：如果插入位置在最后，也就是连接两个字符串，那么复杂度为O(1)，如果是在其他位置，那么与数组一致，为O(n)；

- 删除单个或多个字符：类似增加，如果在最后，则为O(1)，如果在其他位置，则为O(n)；

- **子串匹配**：

    - 在字符串A中查找字符串B，A的长度为n，B的长度为m，n>=m；

    - 方法：两个嵌套循环进行字符串比对，复杂度为O(nm)；

        ![substring](E:\gifs\substring.gif)

#### 例子

- 例子1：两个字符串的最长公共子串；

    - 这个最佳方法是使用动态规划构建二维矩阵，可以在O(nm)的时间内完成，这里使用上述的子串匹配方法；
    - 方法：
        1. 首先两层循环找相同的字符，找到后再一层循环计算子串长度，因此复杂度为O(nmm)；

- 反转字符串中的每个**单词**：

    ```python
    str_ = "the sky is blue"
    str_reserved = ' '.join(str_.split(' ')[::-1])
    ```

    

### 树和二叉树：分支关系与层次结构下，如何有效实现增删查

树是由节点和边组成的没有环的数据结构，用的最多的是二叉树，即每个节点最多有两个子节点，两个特殊的二叉树：

- 满二叉树，除了叶子节点外所有节点都有两个子节点，整棵树是完全对称的；
- 完全二叉树，除了最后一层，其余各层的节点都有两个子节点，即满二叉树是一种特殊的完全二叉树，所谓**完全**，指的是当我们顺序存储时，对内存空间的完全使用没有浪费；

#### 存储结构

- 链式存储：父节点与子节点间通过指针连接，如果是二叉树，则由left和right两个指针；

    ![image-20200616155244043](C:\Users\pc001\AppData\Roaming\Typora\typora-user-images\image-20200616155244043.png)

- 顺序存储：按照规律（比如广度优先）将节点依次放入连续内存空间中，一个特点是i位置的节点的左子节点位置为2\*i，右子节点为2\*i+1，也因为如此，如果不是完全二叉树，那么空间就会有部分是浪费的，以支持这种位置之间的关系；

    ![image-20200616155331717](C:\Users\pc001\AppData\Roaming\Typora\typora-user-images\image-20200616155331717.png)

    ![image-20200616155536277](C:\Users\pc001\AppData\Roaming\Typora\typora-user-images\image-20200616155536277.png)

#### 树的基本操作

此处以二叉树为例，二叉树作为一种特殊的树结构，被使用的是最多的，包括基于二叉树的各种扩展树结构应用非常广泛，比如排序算法、索引算法、机器学习等；

##### 基本二叉树

- 树的遍历：分为前、中、后序三种，这里的前中后指的是父节点的顺序，复杂度为O(n)；

    ![image-20200616155942905](C:\Users\pc001\AppData\Roaming\Typora\typora-user-images\image-20200616155942905.png)

- 树的增删：排除掉查找的部分，复杂度为O(1)；

##### 二叉查找树（二叉搜索树）

![image-20200616160351803](C:\Users\pc001\AppData\Roaming\Typora\typora-user-images\image-20200616160351803.png)

特性：

- 任意一个节点的左子节点均小于自身；
- 任意一个节点的右子节点均大于自身；
- 尽力避免数值相等的节点；
- 对二叉搜索树进行中序遍历，得到的输出序列是递增的；

增删查：

- 查找：典型的二分查找，复杂度为O(logn)；
- 插入：类似查找，先通过二分方式定位，然后插入即可，复杂度依然为O(logn)，与普通二叉树相比主要优化点在于遍历的速度上，插入大家都是O(1)；
- 删除：删除比较复杂，原因在于删除后依然要保持二叉搜索树的特殊结构来支撑它的特性；
    - 情况1：如果删除的是叶子节点，那么直接删除即可，复杂度为O(logn)；
    - 情况2：如果删除的节点只有一个子节点，那么直接将改节点的父节点指向该节点的子节点即可，复杂度依然为O(logn)；
    - 情况3：要删除的节点有两个子节点，那么有两种方式处理；
        - 方式1：找到该节点的左子树中最大值的节点，替换到要删除的节点，复杂度为O(logn)+O(logn)；
        - 方式2：找到该节点的右子树中最小值的节点，替换到要删除的节点，复杂度为O(logn)+O(logn)；
        - **注意**：上述复杂度没有考虑替换操作，替换不仅仅是修改当前要删除的节点的值，同时还要删除最大或最小值对应的节点，因此又是要给O(logn)；
        - 最终复杂度为O(logn)+O(logn)+O(logn)；

#### 例子

- 例子1：判断一个字符串A是否出现在已有的字符串集合（cat, car, city, dog,door, deep）S中，假设S中没有类似deep和dee这种情况的字符串；

    - 分析：如果是暴力法，那么需要O(nm)，也就是两层嵌套循环，但是其实很多字符串集合中的字符串的前缀都是一样的，那么把这种关系统计出来就可以减少很多比对的操作，这种共同前缀的关系可以由树结构（**字典树**）表示：

        ![image-20200616161814678](C:\Users\pc001\AppData\Roaming\Typora\typora-user-images\image-20200616161814678.png)

    - 字典树特性：

        - 根节点不包含具体内容；
        - 除根节点外每个节点包含一个字符；
        - 从根节点到某个叶子节点连起来就是集合中的一个字符串；

    - 方法：

        - 构建字典树；

        - 对于给定字符串A，判断其能够走完这棵树，如果可以则存在，否则就不存在于原字符串集合中；

            ![trie](E:\gifs\trie.gif)

- 二叉树的层次遍历：

    ```python
    from collections import defaultdict
    from functools import reduce
    
    class Node:
        left,right,val = None,None,None
        def __init__(self,val):
            self.val = val
    
    def level(node,lvl=0):
        if not node:
            return
        if len(result)<=lvl:
            result.append([])
        result[lvl].append(node.val)
        level(node.left,lvl+1)
        level(node.right,lvl+1)
    
    root = Node(16)
    l = Node(13)
    r = Node(20)
    root.left = l
    root.right = r
    ll = Node(10)
    lr = Node(15)
    l.left = ll
    l.right = lr
    rr = Node(22)
    r.right = rr
    rrl = Node(21)
    rrr = Node(26)
    rr.left = rrl
    rr.right = rrr
    
    result = []
    level(root)
    print(reduce(lambda x,y:x+y, result))
    ```

    

### 哈希表：如何利用好高效率查找的“利器”

又称散列表，作用在于可以提升按数值查找的速度，这也是之前的线性表、数组、字符串、树等在查找上的一个通病，普遍都需要遍历全部或者部分数据；

#### 核心思想

之前的数据结构，数据存储位置与数值之间没有联系，这使得查找需要遍历和比对，而Hash表的设计采用了函数映射的思想，将记录的存储位置和记录的关键子关联起来，这样就可以直接根据关键子获取到对应位置，而不需要挨个遍历比对，当然需要数组按索引一步到位的支持，即 地址 = f(关键字)；

#### 设计Hash函数

Hash函数的设计直接影响Hash表的性能，如果计算过于复杂，那么得不偿失，如果有太多的Hash冲突（不同的关键字计算得到同一个地址），那么就无法保证在接近于O(1)的时间内定位到地址；

如何设计Hash函数：

- 直接定制法：哈希函数为关键字到地址的线性函数，如H(key) = a*key+b，这里的a和b都是设置好的常数；
- 数字分析法：假设关键字集合中每个关键字都是由N个数字组成，从中提取分布均匀的M个组成地址，比如取名字中每个字的拼音的开头第一个字母的ASCII码；
- 平方取中法：对关键字的数字取平方，扩大差异，再取中间几位作为地址；
- 折叠法：将关键字阶段为N个长度为M的小段，将小段叠加后，再使用数字分析法等；
- 除留余数法：地址为 key mod p，这里的p是提前设置的；

需要注意的是，无论是怎么样的Hash函数，理论上只要存储的数据足够多，总会有Hash冲突出现，这里只能是尽量规避，而无法保证100%没有；

#### 解决Hash冲突

- 开放地址法：当出现Hash冲突时，利用某种规则向后探测，直到找到一个空的位置为止；

    ![](E:\gifs\开放地址法.gif)

- 链地址法：将Hash值一样的点在一个线性表中依次存储；

    ![](E:\gifs\链地址法.gif)

#### 优劣势分析

- 优势：插入和删除方面基本可以达到接近常量时间内完成，而在查找上比树的O(lgn)还要快；
- 劣势：没有顺序的概念，无法按照某个顺序遍历（因为存储都是按照Hash而不是数值来的），关键字的重复会导致大量的Hash冲突降低性能；

#### Hash表的基本操作

增加删除的细节操作取决于Hash表在链地址法时选择的扩展数据结构，而查找则是通过Hash函数得到Hash值，按照这个地址索引到对应为止的元素，如果有多个，则后续进行扩展结构下的查找操作；

#### 案例

- 将关键字序列{7,8,30,11,18,9,14}存储到Hash表中，Hash函数为：H(key) = (key*3)%7，Hash冲突处理使用线性探测法；
    - 首先求出每个关键字对应的Hash值：{7:0,8:3,30:6,11:5,18:5,9:6,14:0}；
    - 插入Hash表，冲突使用线性探测法：{7:0,14:1,8:3,11:5,30:6,18:7,9:8}；
    - 按值查找7：
        - H(7) = 0；
        - 去位置0找到7，结束；
    - 按值查找18：
        - H(18) = 5；
        - 去位置5找到11，不对，线性探测规则，依次向后，直到找到位置7为止，结束；
        - 这里有个问题，如果Hash表长度没有限制，则通过线性探测方式就无法结束查找；
- 在线系统，实时接收用于提交的字符串关键字，并返回用户这个字符串被提交的次数；
    - 采用数组存储，则需要O(n)的时间；
    - 采样Hash表类的字典等，则可以通过实时更新关键字对应的数字，并且查找只需要O(1)；

## 算法思维基础

数据结构与算法目的都是降低运行时间，数据结构是从数据组织形式的角度进行，大多数时候就是空间换时间，而算法则是从数据处理方式的角度进行；

### 递归：利用递归求解汉诺塔问题

所谓递归指的是函数的定义中调用了自身；

两层含义：

- 递归解决的问题必须可以分解为若干个规模更小、与原问题形式相同的子问题，并且这些问题都可以由同样的思路解决；
- 递归需要有明确的终点，或者说回溯的条件，否则就会永远无限的进行下去；

#### 算法思想

递归的数学模型其实就是数学归纳法，当一个问题可以拆解为几个规模更小的问题时，且这种拆解有终止条件，那么就可以应用递归来解决；

经典案例 - 二叉树的遍历：

![](E:\gifs\递归打印二叉树.gif)

伪代码：

```python
def midBinaryTree(root): # 中序遍历二叉树
    if not root:
        return # 终止条件
    printBinaryTree(root.left) # 问题拆解
    print(root)
    printBinaryTree(root.right) # 问题拆解
```

#### 案例

- 汉诺塔：

    ![](E:\download\汉诺塔.png)

    - 抽象为递归能解决的问题，将n个盘子从x移动到z可以拆解为以下3步：
        1. 将n-1个盘子移动到y；
        2. 将第n个盘子移动到z；
        3. 将n-1个盘子移动到z；
    - 递归体为上述的步骤1和3，终止条件为只剩下一个最小的盘子时，此时可以随意移动；

    ![](E:\gifs\递归解决汉诺塔.gif)

### 分治：利用分治法完成数据查找

分而治之，将大规模的、复杂度高的问题分解为若干个小规模、复杂度低的问题，最终对小问题的结果进行合并得到最终答案，这里看起来与递归很像，这也是分治基本都采用递归实现的原因；

一般来说虽然问题规模的增长，复杂度高的算法的增加速度通常是指数级的，因此有必要降低算法的复杂度来适应大规模问题时的解决速度；

在排序领域，代表算法就是快速排序和归并排序，二者都是以分治法为基本思想的算法，复杂度都能达到O(nlgn)；

#### 快速排序和归并排序

快速排序伪代码：

```python
def handle(A,base):
    return A_ # 将A中的元素大于base的放到右边，小于等于base的放到左边
def quickSort(A):
    if not A:
        return
    handle(A[1:],A[0])
    quickSort(A_left)
    quickSort(A_right)
    return A
```

归并排序伪代码：

```python
def merge(a,b):
    return A_ # 合并a和b两个有序序列
def mergeSort(A):
    if A.len == 1:
       	return A
   	return merge(mergeSort(A_left),mergeSort(A_right))
```

#### 分治法的使用方法

1. 难度在降低：即原问题的解决难度，随着数据的规模的缩小而降低；
2. 问题可分：原问题可以分解为若干个规模较小的同类型问题，这是前提；
3. 解可以合并：即若干个小问题的解可以由某种方式合并为原问题的解；
4. 互相独立：各个子问题直接互相独立，即某个子问题的解不会干扰其他子问题的解，否则就需要求解公共子问题，这会降低效率；

在使用递归实现中，每一轮递归，分治法都包含了**分解问题**、**解决问题**、**合并问题**；

二分查找也是一个经典的分治思想的算法，伪代码如下：

```python
def binarySearch(A,target): # A为单调递增序列
    if not A:
        return
    mid = A.len/2
    if A[mid]==target:
        return mid
   	elif A[mid] > target:
    	return binarySearch(A[:mid],target)
    else:
        return binarySearch(A[mid+1:],target)
```

可以看到在二分查找的每一轮递归中，按照mid值与target的关系将问题规模不断缩小，同时如果mid等于target则直接解决了，通过return合并了结果；

#### 练习题

在一个有序数组中，查找出第一个大于9的数字，假设一定存在这样的值，例如{-1,3,3,7,10,14,14}，则返回10；

```python
def binarySearch(A,target):
    if not A:
        return
    if len(A) == 1:
        return A[0] if A[0] > target else None
    mid = int(len(A)/2)
    if A[mid] <= target < A[mid+1]:
        return A[mid+1]
    elif target >= A[mid+1]:
        return binarySearch(A[mid+2:],target)

arr = [-1,3,3,7,10,14,14]
binarySearch(arr,9)
```

### 排序：经典排序算法原理解析与优劣对比

使得无序的数据变得有序的过程称之为排序，同样使用以下3个指标衡量其性能：

1. 时间复杂度：最好、最坏以及平均运行时间；
2. 空间复杂度：复杂度为1时称之为原地排序；
3. 稳定性：相等的数据，排序后的相对位置是否会变化；

#### 常见排序算法

- 冒泡排序：

    ![](E:\gifs\冒泡排序.gif)

    - 从第一个数据开始依次比较相邻的元素，如果前者大于后者，则交换其位置，每轮都能保证该轮的最后一个元素为当前最大；
    - 最好时间复杂度为O(n)，即遍历一遍发现没有一个需要交换的，这也是冒泡排序的结束条件；
    - 最坏情况为O(n^2)，即序列是完全相反的，每轮排序都需要遍历到该轮结束点（虽然这个点是逐渐退后的）；
    - 平均复杂度依然为O(n^2)，平均一般都等于最坏；
    - 空间复杂度为O(1)，另外元素相等时不交换，因此是稳定的；

- 插入排序：

    ![](E:\gifs\插入排序.gif)

    - 从第二个元素开始插入到前面的已排序部分序列中，直到最后一个元素为止；
    - 最好时间复杂度为O(n)，当序列有序时，只需要从第二个遍历到最后一个，每一轮只需要对比一次；
    - 最坏同样为O(n^2)，数组完全为逆序时，每一轮都需要比对所有的有序序列部分；
    - 空间复杂度为O(1)，且同样是稳定的；

- 归并排序：

    ![](E:\gifs\归并排序.gif)

    - 首先将序列不断二分至每个子序列都只有一个元素为止，再对每两个有序子序列进行合并；
    - 最好、最坏、平均均为O(nlogn)，它的执行过程与序列是否有序等无关，其中n为对有序序列进行合并的消耗，而logn则是二分的消耗；
    - 空间复杂度为O(n)，每次合并都需要开辟临时数组，稳定的；

- 快速排序：

    ![](E:\gifs\快速排序.gif)

    - 选择一个基准值，将大于该值的移动到左边，小于该值的移动到右边，再分别对基准值左边和右边两个子序列做同样的操作；
    - 最好情况下为O(nlogn)，即每次选择基准都能选中中位值；
    - 最坏情况下为O(n^2)，即每次选中的都是最大或者最小值，那么就需要进行n次，也就从logn增长到了n；
    - 平均情况下为O(nlogn)，一般很难选中即便情况；
    - 空间复杂度为O(1)，使用的时交换法；
    - 因为是交换法，所以是不稳定的；

### 动态规划：通过最优子结构，完成复杂问题求解 

扩展理解1：

> 1+1+1+1+1+1+1+1 = ?
>
> 计算可知，等于8
>
> 那么在左边再加一个1呢？
>
> 等于9
>
> 为什么这么快得到答案，因为我们知道其余部分为8，记住了，就不需要在计算一遍，所谓DP，就是一种fancy的方式表达记住了一部分从而节省时间的方法，所以基础依然是空间换时间；

扩展理解2：

> 对于最短路径计算，假如某一层有A,B,C三个节点，那么到此我们只需要保留从起始点到A的最短路径，到B的最短路径，到C的最短路径这三条即可，无需保留全部可能的路径；

[扩展理解3](https://www.zhihu.com/question/39948290)：

> 问题满足以下两点：
>
> 1. 问题的答案依赖于问题的规模，即问题的所有答案构成了一个数列；
> 2. 大规模问题的答案可以由小规模问题递推得到，也就是转移方程；
>
> 应用DP：
>
> 1. 转移方程：假设已知f(1)到f(n-1)的所有答案，用他们来表示f(n)；
> 2. 缓存复用以往结果，这也是DP比穷举效率高的原因；
> 3. 按顺序从小规模到大规模算；
>
> 简单例子1 - 斐波那契数列：
>
> ​	斐波那契数列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……  
>
> ​	当前值为前两个值的和，那么第n个值为多少？
>
> 	1. 转移方程：f(n) = f(n-1) + f(n-2)；
>  	2. 缓存复用：当计算f(3)时需要用到f(2)，计算f(4)时同样需要用到f(2)，因此可以通过一个一维数组计算每个位置的值避免重复计算；
>  	3. 从0到n就是规模从小到大的过程；
>
> ```python
> # 简单递归
> # 简单递归关键在于没有考虑缓存复用，导致大量重复计算，这个大量甚至是在数量级上的大量，简单递归复杂度为O(2^n)；
> def fib(n):
>     if n<2:
>         return n
>     return fib(n-1)+fib(n-2)
> 
> # DP
> # 可以看到，转移方程与递归是一致的，但是DP用了res来存储中间数据，避免重复计算，大大降低了复杂度，DP算法下，复杂度仅为O(n)；
> def fib(n):
>     res = [0,1]
>     for i in range(2,n+1):
>         res.append(res[i-2]+res[i-1])
>     return res[-1]
> ```
>
> 中等例子2 - 不同路径：
>
> mxn网路上在0,0有一个机器人，需要走到m,n位置，它只能向下或者向右，问由多少种走法？
>
> 1. 转移方程：f(m,n) = f(m-1,n) + f(m,n-1)；
> 2. 缓存复用：起点到每个位置的可能走法数都需要记录，因为是矩阵，因此需要二维数组；
> 3. 从起点到终点的过程，规模不断扩大，且这个顺序正好可以利用之前的临时数据；
>
> ```python
> def diffRoute():
>     result = [[0,1,-1,-1,-1,-1,-1],[1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1]]
>     for i in range(0,len(result)):
>         for j in range(0,len(result[0])):
>             if result[i][j]==-1:
>                 up = result[i-1][j] if i>0 else 0
>                 left = result[i][j-1] if j>0 else 0
>                 result[i][j] = up + left
>     return result[-1][-1]
> ```
>
> 复杂例子3 - 正则表达式匹配：
>
> 给一个string和一个pattern，实现一个支持'.'和'*'的正则表达式，.代表一个任意字符，\*表示它前面那个字符的0或n个重复连续；
>
> 1. 转移方程：xxxx；
> 2. 缓存复用使用二维bool数组；
> 3. 按顺序从小到大；

之前的分治法需要满足下列四个条件：

1. 问题的解决难度与规模有关，如何无关也就没有划分的必要了；
2. 原问题可以被分解；
3. 子问题的解可以合并为原问题的解，并且这个合并速度要比较快；
4. 所有的子问题互相独立；

有一种情况下问题独独不满足第四个条件，这种情况就需要使用动态规划算法；

从数学的角度看，动态规划是一种运筹学方法，是在多轮决策过程中的最优方法，每一轮决策可以看作是一个子问题，与分治法不同的是，这里的每个子问题之间都是互相依赖关系；

#### 典型问题 - 最短路径

![](E:\download\最短路径.png)

寻找从A到G的最短路径，动态规划的一个重要概念是**状态**，在这里，每一轮的状态就是当前可选的节点；

#### 动态规划的基本方法

宏观通用方法论（下面的k表示第 k轮）：

1. **分阶段**：将原问题划分为几个子问题，每个子问题都是一个阶段，之间可以不满足独立性；
2. **找状态**：选择合适的状态变量Sk，它需要能描述多轮决策过程的演变，更像是决策可能的结果；
3. **做决策**：确定决策变量Uk，每一轮的决策就是该轮当前所有可能的决策动作的集合；例如上述最短路径问题，处于D1时的可能的动作为D1-E1和D1-E2；
4. **状态转移方程**：核心步骤，即Sk+1 = Uk(Sk)，例如Sk为D1，Uk(D1)选择D1-E2，那么Sk+1就是E2；
5. **定目标**：写出代表多轮决策目标的指标函数V_k,n，由目标函数确定每一轮的选择；
6. **确认终止条件**；

基本概念： 

- **策略**：每轮的动作就是决策，多轮决策合在一起称之为策略；
- **策略集合**：每轮决策的不同会使得策略不同，所有不同的策略组成策略集合，动态规划的任务就是从中选择一个最佳的策略；

动态规划问题需要满足的条件：

1. **最优子结构**：原问题的最优解包括的子问题同样也是最优解，比如A到G的最短路径经过D3，那么A到D3的最短路径与A到G路过D3是一致的；
2. **无后效性**：后续子问题的决策无法影响之前的子问题的决策；
3. **有重叠子问题**：子问题不独立，具备前后依赖关系，这也是区别于分治法的条件；

#### 案例

最短路径问题：

1. 分阶段：原问题为从A到G的最短路径，因为节点是分层的，因此每一层之间都是一个子问题，即A到B，B到C，C到D，等；
2. 找状态：S1 = {A}，S2 = {B1,B2}，S3 = {C1,C2,C3,C4}，S4 = {D1,D2,D3}，S5 = {E1,E2,E3}，S6 = {F1,F2}，S7 = {G}；
3. 做决策：决策就是每一轮中各个节点即他们连向后续节点的边，对于第一轮有U1(A)，可能的结果是B1和B2；
4. 状态转移方程：Sk+1 = Uk(Sk)；
5. 定目标：V_k,7(S1=A,S7=G) = sum(dk(sk,uk),k=1~7)，其中dk(sk,uk)表示第k轮时，状态sk下选择uk动作的距离，我们的目标则是最小化这个函数结果；
6. 终止条件：S1=A，S7=G；
7. 递归思路：A到G的最短路径可以看作min(A到F1+4，A到F2+3)，同样A到F1和F2可以继续递归向前，直到A到B，此时可以直接求解并回溯合并问题解；

**V_k,7(s1=A,s7=G)**简化为V7(G)，那么优化目标就是min V7(G)；

计算迭代过程详解：

1. 第六轮决策：
    1. 原问题等价于min{V6(F1)+4,V6(F2)+3}；
    2. 最优子结构原理，分别求解min V6(F1)和min V6(F2)；
    3. 此时路径候选为A->F1->G和A->F2->G；
2. 第五轮决策：
    1. min V6(F1)等价于min{V5(E1)+3,V5(E2)+5,V5(E3)+6}；
    2. min V6(F2)等价于min{V5(E1)+5,V5(E2)+2,V5(E3)+6}；
    3. 原问题等价于min{V5(E1)+3+4,V5(E2)+5+4,V5(E3)+6+4,V5(E1)+5+3,V5(E2)+2+3,V5(E3)+6+3}；
    4. 上式化简得到：min{V5(E1)+7,V5(E2)+5,V5(E3)+9}；
    5. 候选路径为A->E1F1G,A->E2F2G,A->E3F2G；
    6. 最优子结构原理，还需要求解min V5(E1),min V5(E2),min V5(E3)；
3. 第四轮决策：
    1. min V5(E1)等价于min{V4(D1)+2}；
    2. min V5(E2)等价于min{V4(D1)+2,V4(D2)+1,V4(D3)+3}；
    3. min V5(E3)等价于min{V4(D2)+2,V4(D3)+3}；
    4. 原问题等价于min{V4(D1)+2+7,V4(D1)+2+5,V4(D2)+1+5,V4(D3)+3+5,V4(D2)+2+9,V4(D3)+3+9}；
    5. 化简得到：min{V4(D1)+7,V4(D2)+6,V4(D3)+8}；
    6. 候选路径为A->D1E2F2G，A->D2E2F2G，A->D3E2F2G；
    7. 最优子结构原理，还需要求解min V4(D1)，min V4(D2)，min V4(D3)；
4. 第三轮决策：
    1. min V4(D1)等价于min{V3(C1)+6,V3(C2)+3}；
    2. min V4(D2)等价于min{V3(C1)+8,V3(C2)+5,V3(C3)+3,V3(C4)+8}；
    3. min V4(D3)等价于min{V3(C3)+3,V3(C4)+4}；
    4. 原问题等价于min{V3(C1)+6+7,V3(C2)+3+7,V3(C1)+8+6,V3(C2)+5+6,V3(C3)+3+6,V3(C4)+8+6,V3(C3)+3+8,V3(C4)+4+8}；
    5. 化简得到：min{V3(C1)+13,V3(C2)+10,V3(C3)+9,V3(C4)+12}；
    6. 候选路径为A->C1D1E2F2G，A->C2D1E2F2G，A->C3D2E2F2G，A->C4D3E2F2G；
    7. 最优子结构原理，还需要求解min V3(C1)，min V3(C2)，min V3(C3)，min V3(C4)；
5. 第二轮决策：
    1. min V3(C1)等价于min{V2(B1)+1}；
    2. min V3(C2)等价于min{V2(B1)+3,V2(B2)+8}；
    3. min V3(C3)等价于min{V2(B1)+6,V2(B2)+7}；
    4. min V3(C4)等价于min{V2(B2)+6}；
    5. 原问题等价于min{V2(B1)+1+13,V2(B1)+3+10,V2(B2)+8+10,V2(B1)+6+9,V2(B2)+7+9,V2(B2)+6+12}；
    6. 化简得到：min{V2(B1)+13,V2(B2)+16}；
    7. 候选路径为A->B1C2D1E2F2G，A->B2C3D2E2F2G；
    8. 最优子结构原理，还需要求解min V2(B1)，min V2(B2)；
6. 第一轮决策：
    1. min V2(B1)等于5，min V2(B2)等于3；
    2. 原问题等价于min{5+13,3+16}；
    3. 得到最短路径为A->B1->C2->D1->E2->F2->G，距离为18；

代码实现：

![](E:\download\最短路径二维数组表示.png)

```python
# 最短路径算法
def shortestRoute(matrix,j):
    if j==0: # 终止条件
        return 0
    # 状态转移
    list_ = [shortestRoute(matrix,i)+matrix[i][j] for i in range(0,j) if matrix[i][j]>0]
    # 计算最小距离
    return min(list_)

matrix = [[0,5,3,0,0,0,0,0,0,0,0,0,0,0,0,0],
         [0,0,0,1,3,6,0,0,0,0,0,0,0,0,0,0],
         [0,0,0,0,8,7,6,0,0,0,0,0,0,0,0,0],
         [0,0,0,0,0,0,0,6,8,0,0,0,0,0,0,0],
         [0,0,0,0,0,0,0,3,5,0,0,0,0,0,0,0],
         [0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0],
         [0,0,0,0,0,0,0,0,8,4,0,0,0,0,0,0],
         [0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0],
         [0,0,0,0,0,0,0,0,0,0,0,1,2,0,0,0],
         [0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0],
         [0,0,0,0,0,0,0,0,0,0,0,0,0,3,5,0],
         [0,0,0,0,0,0,0,0,0,0,0,0,0,5,2,0],
         [0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,0],
         [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4],
         [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3]]
shortestRoute(matrix,len(matrix[0])-1)
```

#### 练习

- 假设有且仅有 1 个最大公共子串。比如，输入 a = "13452439"， b = "123456"。由于字符串 "345" 同时在 a 和 b 中出现，且是同时出现在 a 和 b 中的最长子串。因此输出 "345"；

    1. 分阶段：；
    2. 找状态：；
    3. 做决策：；
    4. 状态转移方程：；
    5. 定目标：；
    6. 终止条件：；

    ```python
    def LCS(s1,s2):
        len1,len2 = len(s1),len(s2)
        res = [[0 for i in range(len1+1)] for j in range(len2+1)]
        result = 0
        for i in range(1,len2+1):
            for j in range(1,len1+1):
                if s2[i-1] == s1[j-1]:
                    res[i][j] = res[i-1][j-1]+1
                    result = max(result,res[i][j])  
        return result
    print(LCS("13452439","123456"))
    ```

## 真题

### 定位问题才能更好地解决问题：开发前的复杂度分析与技术选型

分析实际算法问题：

1. 明确目标：尽可能低的时间和空间复杂度，解决问题并实现相关代码；
2. 定位问题：更高效的解决问题；
    1. 什么类型的问题：排序、查找、最优化；
    2. 复杂度下限是多少，即最低的时间复杂度可能是多少；
    3. 使用哪些数据结构或者算法思维能解决问题；

在无序数组中找最大值：

1. 目标：找到最大值max_val；
2. 定位：
    1. 查找类型的问题；
    2. 查找下限是O(logn)，但是要求是有序，这里复杂度最低是O(n)；
    3. 不需要复杂的数据结构，一层循环，动态更新最大值即可；

#### 通用解题的方法论

1. 复杂度分析：问题复杂度的上限、下限各是多少；
2. 定位问题：定位问题并设计数据结构与算法思维；
3. 数据操作分析：根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间；
4. 编码实现；

#### 案例

- 例1：无序数组中找出出现此处最多的数字；

    ```python
    arr = [1, 3, 4, 3, 4, 1, 3, 1]
    dict_ = {}
    for num in arr:
        dict_[num] = dict_.get(num,0)+1
    max_count = 0
    max_val = 0
    for k in dict_.keys():
        if dict_[k] > max_count:
            max_count = dict_[k]
            max_val = k
    print(max_val,max_count)
    ```

- 例2：two sums，无序数组中找到两个数字之和为指定值；

    ```python
    arr = [6,5,8,1,4,2,3,10,0,11,7]
    target = 10
    dict_ = {}
    idxs = []
    for idx,num in enumerate(arr):
        if target-num in dict_.keys():
            idxs = [dict_[target-num],idx]
            break
        dict_[num] = idx
    print(idxs)
    ```

### 真题案例（一）：算法思维

#### 题目1：斐波那契数列

输入x，输出第x位的斐波那契数，例如，输入4，输出2，要求使用递归实现；

1. 复杂度分析：要计算fib(n)，就需要知道fib(n-1)和fib(n-2)，以此类推，复杂度最低也需要O(n)；

2. 问题定位：问题指定了需要递归实现，终止条件为n等于0和1；

3. 数据操作方面：需要对数字进行求和，这里不需要复杂的数据结构；

4. 实现代码：

    ```python
    # 0 1 1 2 3 5 8 ....
    def fib(x):
        if x==1 or x==2:
            return x - 1
        return fib(x-1) + fib(x-2)
    ```

#### 题目2：判断数组中是否存在某个数

![image-20200709112239964](C:\Users\pc001\AppData\Roaming\Typora\typora-user-images\image-20200709112239964.png)

给定一个经过任意位数的旋转后的排序数组（可以看作是两个有序数组链接在一起），判断某个数是否再里面，例如给定{4, 5, 6, 7, 0, 1, 2}，前三位旋转到了末尾，输入0，输出4；

1. 复杂度分析：直接检索的复杂度为O(n)，但是这里的旋转后的排序数组算是局部有序，有序数组检索使用二分查找可以达到O(logn)；

2. 问题定位：查找类型问题，在一个旋转后有序数组；

3. 数据操作方面：需要索引数组中的数字，并对比target，难点在于对比了mid后是向左走还是向右走；

4. 实现代码：

    ```python
    # 2 4 5 6 7 0 1 mid=6 左边有序，右边旋转
    # 7 0 1 2 4 5 6 mid=2 左边旋转，右边有序
    # 5 6 7 0 1 2 4 mid=0 左边有序，右边有序，极端情况，正好在边界
    def search(arr, target, offset):
        if not arr or len(arr) <= 0:
            return -1
        mid = int(len(arr)/2)
        if arr[mid]==target:
            return mid + offset
        print(arr,mid,arr[mid])
        if arr[0] < arr[mid-1]:
            if target >= arr[mid-1]:
                return search(arr[:mid], target, offset)
            else:
                return search(arr[mid+1:], target, offset + mid+1)
        else:
            if arr[mid-1] < arr[mid]:
                if arr[mid-1] >= target:
                    return search(arr[:mid], target, offset)
                else:
                    return search(arr[mid+1:], target, offset + mid+1)
            else:
                if arr[0] >= target:
                    return search(arr[:mid], target, offset)
                else:
                    return search(arr[mid+1:], target, offset + mid+1)
        return -1
    
    arr = [2,4,5,6,7,0,1]
    arr = [7,0,1,2,4,5,6]
    arr = [5,6,7,0,1,2,4]
    target = 0
    search(arr, target, 0)
    ```

#### 题目3：最大公共子串

输入两个字符串，利用动态规划，求解最大公共子串，比如输入a=13452439，b=123456，则返回345；

暴力法：

```python
def maxSubStr(s1,s2):
    '''
    暴力法：O(n^3)；
    '''
    maxLen = 0
    maxStr = ''
    for i in range(len(s1)):
        for j in range(len(s2)):
            if s2[j]==s1[i]:
                k = 1
                while k+i < len(s1) and k+j < len(s2) and s1[k+i]==s2[k+j]:
                    k += 1
                if k > maxLen:
                    maxLen = k
                    maxStr = s1[i:k+i]
    return maxLen,maxStr

maxSubStr('13452439','123456')
```

DP法：

```python
def maxSubStr(s1,s2):
    '''
    DP：动态规划，复杂度降低一个数量级O(n^2)；
    '''
    maxLen = 0
    maxStr = ''
    matrix = [[0 for a in s1] for b in s2]
    for i in range(len(s1)):
        for j in range(len(s2)):
            if s2[j]==s1[i]:
                matrix[j][i] = 1 + (matrix[j-1][i-1] if i>=1 and j>=1 else 0)
                if matrix[j][i] > maxLen:
                    maxLen = matrix[j][i]
                    maxStr = s1[i-maxLen+1:i+1]
    return maxLen,maxStr

maxSubStr('13452439','123456')
```

### 真题案例（二）：数据结构

#### 题目1：反转字符串中的单词

输入“This is a good example”，输出"example good a is This"；

```python
# 不使用数据结构的暴力法需要两个循环
# 使用栈来实现逆序更加合理自然
# 当然python中直接反转数组也很方便
def reserveStr(str):
    arr = []
    tmp = ''
    for s in str+' ':
        if s == ' ' and tmp!='':
            arr.append(tmp)
            tmp = ''
        else:
            tmp += s
    return ' '.join(arr[::-1])
reserveStr('This is a good example')
```

#### 题目2：数的层序遍历

给定一棵树，按照层次顺序遍历并打印这棵树；

```python
class Node:
    val = None
    left = None
    right = None
    def __init__(self,val,left,right):
        self.val = val
        self.left = left
        self.right = right

# 遍历树，从根节点开始，入队出队的操作可以用队列的思想实现
def printTree(nodes):
    if not nodes:
        return []
    childs = []
    for node in nodes:
        if node:
            childs += [node.left,node.right]
    return [node.val for node in nodes if node] + printTree(childs)

ll = Node(10,None,None)
lr = Node(15,None,None)
l = Node(13,ll,lr)
rrl = Node(21,None,None)
rrr = Node(26,None,None)
rr = Node(22,rrl,rrr)
r = Node(20,None,rr)
root = Node(16,l,r)
print(printTree([root]))
```

#### 题目3：查找数据流中的中位数

在一个流式数据中，查找中位数，如果是偶数个，则返回偏左边的那个元素；

```python
# 这个是流式数据，实时在增加的；
# 这里使用的是大顶堆和小顶堆的数据结构来抽象化问题；
```

#### 练习：二叉树蛇形层序遍历

也就是说奇数层从左到右，偶数层从右到左；

```python
# 遍历树，从根节点开始，入队出队的操作可以用队列的思想实现
def printTree(nodes, lvl):
    if not nodes:
        return []
    childs = []
    for node in nodes:
        if node:
            childs += [node.left,node.right]
    return [node.val for node in (nodes if lvl%2==1 else nodes[::-1]) if node] + printTree(childs, lvl+1)
```

### 真题案例

### 真题案例

## 最后

